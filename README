
INTRODUCTION
------------

The AoEde is the virtual EtherDrive (R) blade, a program that makes a
seekable file available over an ethernet local area network (LAN) via
the ATA over Ethernet (AoE) protocol.

The seekable file is typically a block device like /dev/md0 but even
regular files will work.  Sparse files can be especially convenient.
When AoEde exports the block storage over AoE it becomes a storage
target.  Another host on the same LAN can access the storage if it has
a compatible aoe kernel driver.

BUILDING
--------

The following command should build the AoEde program on a Linux-based
system:

  make

For FreeBSD systems, include an extra parameter like so:

  make PLATFORM=freebsd

For the list of configurable options and their description see config.h

EXAMPLES
--------

There is a "AoEded" script that daemonizes the program and sends its
output to the logger program.  Make sure you have logger installed if
you would like to run AoEde as a daemon with the AoEded script.

  ecashin@kokone AoEde$ echo 'I have logger' | logger
  ecashin@kokone AoEde$ tail -3 /var/log/messages
  Feb  8 14:52:49 kokone -- MARK --
  Feb  8 15:12:49 kokone -- MARK --
  Feb  8 15:19:56 kokone logger: I have logger

Here is a short example showing how to export a block device with a
AoEde.  (This is a loop device backed by a sparse file, but you could
use any seekable file instead of /dev/loop7.)

  ecashin@kokone AoEde$ make
  cc -Wall   -c -o aoe.o aoe.c
  cc -Wall   -c -o linux.o linux.c
  cc -Wall   -c -o ata.o ata.c
  cc -o AoEde aoe.o linux.o ata.o
  ecashin@kokone AoEde$ su
  Password: 
  root@kokone AoEde# modprobe loop
  root@kokone AoEde# dd if=/dev/zero bs=1k count=1 seek=`expr 1024 \* 4096` of=bd
  -file
  1+0 records in
  1+0 records out
  1024 bytes transferred in 0.009901 seconds (103423 bytes/sec)
  root@kokone AoEde# losetup /dev/loop7 bd-file  
  root@kokone AoEde# ./AoEde 9 0 eth0 /dev/loop7 
  ioctl returned 0
  4294968320 bytes
  pid 16967: e9.0, 8388610 sectors

Here's how you can use the Linux aoe driver to access the storage from
another host on the LAN.

  ecashin@kokone ecashin$ ssh makki
  Last login: Mon Feb  7 10:25:04 2005
  ecashin@makki ~$ su
  Password: 
  root@makki ecashin# modprobe aoe
  root@makki ecashin# aoe-stat
      e9.0            eth1              up
  root@makki ecashin# mkfs -t ext3 /dev/etherd/e9.0
  mke2fs 1.35 (28-Feb-2004)
...
  Creating journal (8192 blocks): done
  Writing superblocks and filesystem accounting information: done
  
  This filesystem will be automatically checked every 24 mounts or
  180 days, whichever comes first.  Use tune2fs -c or -i to override.
  root@makki ecashin# mkdir /mnt/e9.0
  root@makki ecashin# mount /dev/etherd/e9.0 /mnt/e9.0
  root@makki ecashin# echo hooray > /mnt/e9.0/test.txt
  root@makki ecashin# cat /mnt/e9.0/test.txt
  hooray

Remember: be as careful with these devices as you would with /dev/hda!

Jumbo Frame Compatibility
-------------------------

AoEde can use jumbo frames provided your initiator is jumbo frame
capable.  There is one small configuration gotcha to consider 
to avoid having the AoEde kernel frequently drop frames.

AoEde uses a raw socket to perform AoE.  The linux kernel will
only buffer a certain amount of data for a raw socket.  For 2.6
kernels, this value is managed through /proc:

root@nai aoe# grep . /proc/sys/net/core/rmem_*
/proc/sys/net/core/rmem_default:128000
/proc/sys/net/core/rmem_max:128000

rmem_max is the max amount a user process may expand the receive
buffer to -- through setsockopt(...) -- and rmem_default is, as you
might expect, the default.

The gotcha is that this amount to buffer does not relate
to the amount of user data buffered, but the amount of
real data buffered.  As an example, the Intel GbE controller
must be given 16KB frames to use an MTU over 8KB.
For each received frame, the kernel must be able to buffer
16KB, even if the aoe frame is only 60 bytes in length.

The linux aoe initiator will use 16 outstanding frames when
used with AoEde.  A good default for ensuring frames are
not dropped is to allocate 16KB for 17 frames:

for f in /proc/sys/net/core/rmem_*; do echo $((17 * 16 * 1024)) >$f; done

Be sure to start AoEde after changing the buffering defaults
as the buffer value is set when the socket is opened.

AoE Initiator Compatibility
---------------------------

The Linux aoe driver for the 2.6 kernel is compatible if you use
aoe-2.6-7 or newer.  You can use older aoe drivers but you will only
be able to see one AoEde per MAC address.


Experimental Tag tracking functionality
---------------------------

Current AoE specification doesn't declare how AoE packet's tag field can
be used by initiator. But at least some of them uses it as monotinically 
incrementing unsigned 32-bit/liddle-endian counter for every new AoE packet. 
This makes possible to reduce duplicated replies transmitted over network 
(RX tags tracking) and to reduce risk of data corruption due to duplicated 
by hardware packet came in wrong order (WRITE tags tracking). 
Both this functionalities are disabled by default and can be enabled by 
specifying command line argument. But be extremely carefull with WRITE tags 
tracking, cause using it with initiator that doesn't meet above behaviour 
can corrupt data! RX tags tracking option is more safe - while used with 
correct initiator it will improve performance, using it with incompatible 
initiator can just cause performance degradation, but not data corruption.
TBD: Add special command in Aoemask request or flag into Aoehdr so initiator 
will explicitely manifest itself as following described tag field behaviour.



Contrib Patches
---------------

see contrib/README

KAoEde
-------

  While AoEde runs as a userland process (like "ls" or "vi"), there
  is another program that runs inside the kernel.  It is called
  kAoEde.  It is alpha software.
